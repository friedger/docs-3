# Create a multisig address using principal-construct?

On the Stacks blockchain, each block has a tenure height - a number indicating its position within a miner's tenure period.

Understanding and accessing this information is really useful when you need to:

- Track block sequences within minure tenures
- Implement logic that depends on tenure-specific block ordering
- Verify block relationships within a single miner's tenure

Let's take a look at the following code to better understand how to work with tenure height information for a given block.

At its core, we're using <HoverLink href="hover:get-stacks-block-info" className="text-[var(--ch-7)]">get-stacks-block-info?</HoverLink> to fetch information about a specific block. This function is particularly looking for something called the <InlineCode codeblock={{language: "clarity", value: "id-header-hash"}}>id-header-hash</InlineCode>, which is essentially a unique identifier for the block.

Think of it like a block's fingerprint - no two blocks will ever have the same one.

```terminal
$ clarinet console
$ ::advance_stacks_chain_tip 1
$ (contract-call? .get-tenure-for-block get-tenure-height burn-block-height)
[32m(ok u3)[0m [1m[0m
```

Now, sometimes when we ask for a block's information, it might not exist (maybe the block height is invalid or hasn't been mined yet). That's where `unwrap!` comes into play.

It's like a safety net - if we can't find the block, instead of crashing, it'll return a nice clean <HoverLink href="hover:error" className="text-[var(--ch-6)]">error response</HoverLink>.

Once we have our block's hash, we use it with `at-block` to peek back in time and grab the <HoverLink href="hover:tenure-height" className="text-[var(--ch-7)]">tenure-height</HoverLink> for that specific block. _The tenure height is an interesting piece of data - it tells us where this block sits in sequence during a particular miner's tenure._

You can think of a tenure as a miner's _"shift"_ where they're responsible for producing blocks, and the tenure height helps us keep track of the order of blocks during their shift.

The function wraps everything up nicely with `ok`, following Clarity's pattern of being explicit about successful operations. This makes it clear to anyone using the function whether they got what they asked for or hit an error.