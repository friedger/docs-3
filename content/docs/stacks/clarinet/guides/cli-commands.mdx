---
title: CLI Commands
description: A comprehensive list of all Clarinet CLI commands and their usage.
---

import { File, Folder, Files } from 'fumadocs-ui/components/files';

## Create a New Project
Create a new Clarinet project with the basic directory structure and configuration files:

```terminal
$ clarinet new my-project
[32mCreate directory[0m [1mmy-project[0m
[32mCreate directory[0m [1mcontracts[0m
[32mCreate directory[0m [1msettings[0m
[32mCreate directory[0m [1mtests[0m
[32mCreate file[0m [1mClarinet.toml[0m
[32mCreate file[0m [1msettings/Mainnet.toml[0m
[32mCreate file[0m [1msettings/Testnet.toml[0m
[32mCreate file[0m [1msettings/Devnet.toml[0m
[32mCreate directory[0m [1m.vscode[0m
[32mCreate file[0m [1m.vscode/settings.json[0m
[32mCreate file[0m [1m.vscode/tasks.json[0m
[32mCreate file[0m [1m.gitignore[0m
[32mCreate file[0m [1m.gitattributes[0m
[32mCreate file[0m [1mpackage.json[0m
[32mCreate file[0m [1mtsconfig.json[0m
[32mCreate file[0m [1mvitest.config.js[0m
```
This will create a project directory with the following directory layout:

<Files className='pointer-events-none'>
  <Folder name="contracts" />
  <Folder name="settings" defaultOpen>
    <File name="Devnet.toml" />
    <File name="Mainnet.toml" />
    <File name="Testnet.toml" />
  </Folder>
  <Folder name="tests" />
  <File name=".gitignore" />
  <File name="Clarinet.toml" />
  <File name="package.json" />
  <File name="tsconfig.json" />
  <File name="vitest.config.js" />
</Files>

The _txt`Clarinet.toml`_ file contains configuration for the smart contracts in your project. When you create contracts in your project, Clarinet will automatically add them to this file.

The _txt`settings/Devnet.toml`_ file contains configuration for accounts in the Clarinet console, including the seed phrases and initial balances for a set of out-of-the-box wallets that you can use for testing in the devnet environment.

## Add a Contract
Add a new contract to your existing project:

```terminal
$ clarinet contract new my-contract
[32mCreated file[0m [1mcontracts/my-contract.clar[0m
[32mCreated file[0m [1mtests/my-contract.test.ts[0m
[33mUpdated Clarinet.toml[0m [1mwith contract my-contract[0m
```

This command updates your project's configuration and creates a new contract file and a corresponding test file:

<Files className='pointer-events-none'>
  <Folder name="contracts" defaultOpen>
    <File name="my-contract.clar" className='bg-[hsl(var(--highlight))]' />
  </Folder>
  <Folder name="settings" />
  <Folder name="tests" defaultOpen>
    <File name="my-contract.test.ts" className='bg-[hsl(var(--highlight))]' />
  </Folder>
  <File name=".gitignore" />
  <File name="Clarinet.toml" />
  <File name="package.json" />
  <File name="tsconfig.json" />
  <File name="vitest.config.js" />
</Files>

```toml
[contracts.my-contract]
path = 'contracts/my-contract.clar'
clarity_version = 2
epoch = 2.4
```

<Callout title="Adding contracts manually">
You can also add contracts to your project by adding the files manually. However, you must add the appropriate configuration to `Clarinet.toml` in order for **Clarinet** to recognize the contracts.
</Callout>

## Check Contracts
Validate the syntax and semantics of your contracts:

```terminal
$ clarinet check
[32mâœ”[0m [1m1 contract checked[0m
$ clarinet check path/to/my-contract.clar
[32mâœ”[0m [1m1 contract checked[0m
```

This command uses the _txt`Clarinet.toml`_ file to locate and analyze all the contracts in the project. If the Clarity code is valid, the command will indicate success with the response below.

<Callout title="Note">
The _console`clarinet check`_ command may also report warnings indicating the code is valid.
</Callout>

## Start Development Console
Launch the Clarinet console for interactive development:

```terminal
$ clarinet console
```

## Debugging
Inside the console, you can use these debugging commands:

```terminal
$ ::trace (contract-call? .my-contract my-function)
$ ::debug (contract-call? .my-contract my-function)
$ break my-function
```

Debug navigation commands:
- _console`step`_ or _console`s`_ - Step into
- _console`finish`_ or _console`f`_ - Step out
- _console`next`_ or _console`n`_ - Step over
- _console`continue`_ or _console`c`_ - Continue execution

Let's take the clarity_`counter`_ contract as an example:

```clarity
(define-map Counters principal uint)

(define-read-only (get-count (who principal))
  (default-to u0 (map-get? Counters who))
)

(define-public (count-up)
  (ok (map-set Counters tx-sender (+ (get-count tx-sender) u1)))
)
```

### Trace

The _console`::trace`_ command expects an expression, so make a _clarity`contract-call?`_ with our _clarity`count-up`_ function and see what happens.

```terminal
$ ::trace (contract-call? .counter count-up)
(contract-call? .counter count-up)  [30m<console>[0m
( get-count tx-sender )  [30mcounter:4:38[0m
  [31mâ†³ args:[0m [1mST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM[0m
    [34mu0[0m
[34m(ok true)[0m
```

### Breakpoints

You can also set a breakpoint at a specific line to better understand what's happening in your contract.

With `::debug`, you can add breakpoints at a specific line of a contract or function to better understand what's happening in your contracts.

```clarity
(define-map Counters principal uint)

(define-read-only (get-count (who principal))
  (default-to u0 (map-get? Counters who))
)

(define-public (count-up)
  (ok (map-set Counters tx-sender (+ (get-count tx-sender) u1)))
)

;; !mark(1:3)
(define-public (count-twice)
  (double)
)

;; !mark(1:6)
(define-private (double)
  (begin
    (unwrap-panic (count-up))
    (count-up)
  )
)
```

```terminal
$ ::debug (contract-call? .counter count-twice)
$ break count-up
```


<Callout title="Breakpoint Commands">
To step through these breakpoints, you can use one of the following commands:

- **Step-in (`step` or `s`)**: Step into the sub-expressions.
- **Step-out (`finish` or `f`)**: Complete execution of the current expression and return the result to the parent.
- **Step-over (`next` or `n`)**: Continue to completion of the current expression, stepping over sub-expressions.
- **Continue (`continue` or `c`)**: Continue execution until hitting a breakpoint or completing execution.
</Callout>

Using the _console`continue`_ command, the breakpoint you set in the _clarity`double`_ function will trigger twice due to two _clarity`count-up`_ calls, which enables you to do variable and map analysis.

## Cost Analysis
Analyze execution costs in the console:

```terminal
$ ::get_costs (contract-call? .my-contract my-function)
$ ::toggle_costs
# Toggles automatic cost display
```

## Start Local Devnet
Launch a local development network with all required services:

```terminal
$ clarinet devnet start
```

Requires Docker to be running locally. See [installing Docker](/guides/install-docker) guide for more information.

## Deployment
Generate a deployment plan:

```terminal
$ clarinet deployments generate --<network>
```
Supported networks: console`devnet`_, console`testnet`_, console`mainnet`_

Deploy contracts:

```terminal
$ clarinet deployments apply --<network>
```

## Add Contract Requirements
Add external contract dependencies:

```terminal
$ clarinet requirements add <contract-principal>
```

Example:
```terminal
$ clarinet requirements add SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.nft-trait
```

## Deployment Plan Transactions

Your deployment plans can include various transaction types:

### Contract Operations
```yaml
- contract-publish:
    contract-name: my-contract
    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
    cost: 5960
    path: contracts/my-contract.clar
    clarity-version: 2

- contract-call:
    contract-id: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.my-contract
    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
    method: my-function
    parameters: []
    cost: 5960
```

### Asset Transfers
```yaml
- stx-transfer:
    expected-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
    recipient: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.my-contract
    mstx-amount: 1000
    memo: '0x01'
    cost: 10000

- btc-transfer:
    expected-sender: mjSrB3wS4xab3kYqFktwBzfTdPg367ZJ2d
    recipient: bcrt1qnxknq3wqtphv7sfwy07m7e4sr6ut9yt6ed99jg
    sats-amount: 100000000
    sats-per-byte: 10
```

### Simnet Operations
```yaml
- emulated-contract-publish:
    contract-name: my-contract
    emulated-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
    path: contracts/my-contract.clar
    clarity-version: 2

- emulated-contract-call:
    contract-id: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.my-contract
    emulated-sender: ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM
    method: my-function
    parameters: []
```

<Callout title="Note">
For functions that take no arguments or read-only functions, use an empty parameters list: `parameters: []`
</Callout>
