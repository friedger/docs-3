---
title: Observing Contract Calls with Chainhook
description: Learn how to use Chainhook to observe smart contract calls.
---

import { Step, Steps } from "fumadocs-ui/components/steps";

import SimpleVote from "../resources/simple-vote.mdx";

The `contract_call` predicate scope is designed to target direct function calls within a smart contract. When triggered, Chainhook will return a payload with transaction data detailing the on-chain events contained in these functions.

<Callout type="warn" title="Requirements">
  To use Chainhook you can either install it
  [directly](/stacks/chainhook/installation) or use [Hiro
  Platform](https://platform.hiro.so/). If you are installing Chainhook, this
  [quickstart](/stacks/chainhook/quickstart) will walk you through setting up a
  predicate file and using it to scan for events.
</Callout>

In this guide, you will learn how to:

1. [Construct a Stacks blockchain Chainhook predicate for a contract call scope](#creating-the-predicate).
2. [Run your Chainhook predicate to generate a payload](#running-the-predicate).
3. [Use a Clarity function to return specific contract data](#return-contract-data-with-the-clarity-function).
4. [Find data related to the contract call within the Chainhook payload](#chainhook-payload).

<Steps>
<Step>

## Creating the predicate

The `predicate` is your main interface for querying the Chainhook data indexer. Chainhook uses your specified `predicate` to select the appropriate blockchain, network, and scope for monitoring transactions.

Run the following command to generate a template for your Stacks `predicate`:

```console
chainhook predicates new contract-call-chainhook.json --stacks
```

<Callout type="info" title="Note">
  Alternatively, [Hiro Platform](https://platform.hiro.so/) has an excellent UI
  to help you to create a `predicate` using a form builder or upload a json file
  containing your `predicate`.
</Callout>

You can view the full predicate example we will be using in this guide below.

<Accordions>
  <Accordion title="contract-call-chainhook.json">

```json
{
  "chain": "stacks",
  "uuid": "1",
  "name": "Contract-Call-Chainhook",
  "version": 1,
  "networks": {
    "testnet": {
      "start_block": 21443,
      "decode_clarity_values": true,
      "expire_after_occurrence": 1,
      "if_this": {
        "scope": "contract_call",
        "contract_identifier": "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.simple-vote-v0",
        "method": "cast-vote"
      },
      "then_that": {
        "http_post": {
          "url": "https://webhook.site/abc123456-789e-0fgh-1ijk-23lmno456789",
          "authorization_header": "12345"
        }
      }
    }
  }
}
```

  </Accordion>
</Accordions>

### Configuring the predicate

To construct the `predicate`, we will specify the Stacks test network `testnet` and the the start_block `21443` (block containing the successful contract deployment).

```json title="contract-call-chainhook.json"
// [!code word:networks]
// [!code word:start_block]
{
  "chain": "stacks",
  "uuid": "1",
  "name": "Contract Call Chainhook",
  "version": 1,
  "networks": {
    "testnet": {
      "start_block": 21443,
      "decode_clarity_values": true,
      "expire_after_occurrence": 1,
  ...
    }
  }
}
```

<Callout type="info" title="Note">
  If you do not want to specify certain configurable like `end-block` and
  `expire_after_occurence`, simply leave these elements out of your `predicate`.
  For more details on the other configurations, as well as the `if_this` and
  `then_that` specifications discussed below, check out [Stacks
  predicates](/stacks/chainhook/concepts/stacks-predicates).
</Callout>

### Defining the scope with the if_this specification

Next, we will need to define the scope of the `predicate` within the `if_this` specification. The `contract_call` scope within our predicate allows Chainhook to observe blockchain data when the specified method is directly called from its contract. In this scope, we identify the contract that contains the method we want to observe using `contract_identifier` and the name of the function in `method`.

```json title="contract-call-chainhook.json"
// [!code word:if_this]
{
  "if_this": {
    "scope": "contract_call",
    "contract_identifier": "STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0",
    "method": "cast-vote"
  }
}
```

<Callout type="warn" title="Warning">
  The function defined in the `method` must be directly called for Chainhook to
  observe events. Calling the function from another contract or from within a
  different function on the same contract will not generate a `payload`.

```clarity
(define-public (call-cast-vote)
  (cast-vote)
)
```

</Callout>

<Callout type="info">
  You can view other `scope` definitions on the
  [Scopes](/stacks/chainhook/references/scopes) reference page.
</Callout>

### Defining the payload destination with the then_that specification

Finally, you need to define how Chainhook delivers the payload when it is triggered by our `predicate` within the `then_that` specification.

When using `file_append`, specify the `path` you want Chainhook to post the payload data to.

```json title="contract-call-chainhook.json"
// [!code word:then_that]
{
  "then_that": {
    "file_append": {
      "path": "/tmp/events.json"
    }
  }
}
```

<Callout type="info">
  Chainhook is unable to write to a file when using `devnet`.
</Callout>

Chainhook can also post its payload to an endpoint using `http_post`, allowing us to specify the endpoint's `url` and `authorization_header`.

```json title="contract-call-chainhook.json"
// [!code word:then_that]
"then_that": {
        "http_post": {
          "url": "https://webhook.site/abc123456-789e-0fgh-1ijk-23lmno456789",
          "authorization_header": "12345"
        }
      }
```

<Callout type="info" title="Note">
  Chainhook requires `https` to post to your endpoint. You can use a service
  like [LocalTunnel](https://github.com/localtunnel/localtunnel) to test locally
  or a site like [WebhookSite](https://webhook.site).
</Callout>

</Step>
<Step>

## Running the predicate

With our `predicate` set up, we can now use Chainhook to monitor blocks that match our `contract_call` scope and analyze the returned payload. Chainhook will track events where this function is directly invoked in a transaction and generate a detailed payload containing transaction data at the block level.

Specify our `contract-call-chainhook.json` predicate file in the following command to scan the Stacks blockchain.

```console
chainhook predicates scan /path/to/contract-call-chainhook.json --testnet
```

<Callout type="info">
  If you are using Platform, creating your Chainhook will automatically begin
  the scan for you.
</Callout>

</Step>
<Step>

## Return contract data with the clarity function

Before we begin looking at our `payload`, let's review the `cast-vote` Clarity function we have specificed in our predicate. This function takes the address calling it, records a vote and stores the voting address. It also `print` to log data that will be useful for building a DApp around the on-chain events we want track. As we review the `payload`, this is the data we will look for.

```clarity title="simple-vote-v0.clar"
// [!code word:cast-vote]
(define-public (cast-vote)
  (begin
    ;; Check if the voter has already voted.
    (asserts! (is-none (map-get? UserVotes tx-sender)) (err ERR_ALREADY_VOTED))

    ;; Update the map that the vote has been cast.  Print vote related data.
    (map-set UserVotes tx-sender { hasVoted: true })
    (var-set VoteCount (+ (var-get VoteCount) u1))
    (print
      {
        notification: "cast-vote",
        payload: {
          status: "Has voted set to true",
          voter: tx-sender,
          totalVotes: (get-total-votes)
        }
      }
    )
    (ok "Vote cast successfully")
  )
)
```

<Accordions>
  <Accordion title="simple-vote-v0.clar">
    <SimpleVote />
  </Accordion>
</Accordions>

<Callout type="info" title="Note">
  This contract has been deployed to the Stacks [testnet
  network](https://explorer.hiro.so/txid/0x312a3c559af0f75381a9eb4540912c310d74682ed3036207ec890ad8cd1aebe6?chain=testnet)
  under the name `STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0`.
</Callout>

</Step>
<Step>

## Chainhook payload

<Callout type="info">
  You can view the full
  [contract-call-payload.json](/contract-call-payload.json) here.
</Callout>

When triggered by our predicate, the `payload` returned by Chainhook is a standarized, block level observation in json format.

Within the `apply` arrays element, the `block_identifer` object gives us the `index` for the observed block height.

```json title="contract-call-payload.json"
// [!code word:block_identifier]
// [!code word:index]
  "block_identifier": {
        "hash": "0x4d88015a6df9ec4f6df875941d87337ce64f8d51608563f80b6e27adeb327e4d",
        "index": 21544
      }
```

<Callout type="warn" title="Warning">
  The hash returned in the `block_identifer` object is not that block hash you
  would see in [Stacks Explorer](https://explorer.hiro.so/?chain=testnet), but
  `index_block_hash` returned from the Stacks API [get
  block](/stacks/api/blocks/get-block) endpoint. You can use the `apply` array's
  metadata object to get the `stacks_block_hash`.
</Callout>

We can retrieve the `stacks_block_hash` by navigating to the the `apply` arrays object `metadata` element. This hash will match the block hash display in the Stacks Explorer.

```json title="contract-call-payload.json"
// [!code word:stacks_block_hash]
"apply": [
  {
    "metadata": {
      ...
      "stacks_block_hash": "0x4ad36f77ff76042f3b7355006556375970b0f99d1232b14a3b4a2eadda4a806a"
      ...
    }
  }
]
```

There is also also a `timestamp` value returned in the `apply` array. This UNIX time stamp represents the initiation of the Stacks block.

```json title="contract-call-payload.json"
"timestamp": 1722208524
```

<Callout type="warn" title="Warning">
  The timestamp returned in this object is not the finalized block time you
  would see in [Stacks Explorer](https://explorer.hiro.so/?chain=testnet), but
  `block_time` returned from the Stacks API [get
  block](/stacks/api/blocks/get-block) endpoint.
</Callout>

### Transaction object

Because Chainhook is triggered on the block level, we will receive a single response that contains data specific to each `transaction` that matches your predicate's `contract_call` scope. To find this data, we start with the `apply` array element of the `payload` object. The single object that makes up the `apply` array contains a child element, the `transactions` array. Every `transaction` will be represents by a single object within this array. This `transaction` object contains its own children elements which can be seen in the example below.

```json
{
  "apply": [
    {
      ...
      "transactions": [
      //transaction object(s)
        {
          "transaction_identifier": { ... },
          "metdata": { ... },
          "operations": [],
        }
      ],
      ...
    }
  ],
  "rollback": [ ... ],
  "chainhook": { ... }
}
```

Once the `transaction` object is returned, we can begin examining important data elements it contains. The first element, `transaction_identifier`, includes a hash value that uniquely identifies your transaction.

```json title="contract-call-payload.json"
"transaction_identifier": {
  "hash": "0x98195af8f888d2f9ca3462c41c1691e7798ea6d9e5e3afe42955c0921f981f2c"
}
```

<Callout type="info" title="Note">
  The `operations` array in your example is empty, as `cast-vote` function does
  not involve the transfer of any assets. When assets are transferred the
  `operations` array would contain a record of every `debit` and `credit` of
  those assets as functions are executed by smart contracts. These records are
  not exclusive to a specific predicate scope.
</Callout>

Next, focus on the `metadata` object within your `contract_call` data. It's crucial to determine the success state of your transaction. Chainhook captures and reports on transactions regardless of their outcome. Utilize the `success` object to assess transaction success. Additionally, extract the `sender` of the transaction and the `result` returned by the contract.

```json title="contract-call-payload.json"
"metadata": {
  ...
  "success": true,
  "sender": "STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV",
  "result": "(ok \"Vote cast successfully\")"
  ...
}
```

Moving forward, examine the `kind` object and its components within your `contract_call`. The data object contains crucial information: `contract_identifier` specifies the contract your function resides on, `method` identifies the function called, and `args` lists the arguments passed when invoking this function. In this case, the `cast-vote` function accepts no arguments, resulting in an empty `args` array.

```json title="contract-call-payload.json"
// [!code word:kind]
{
  "metadata":
  ...
  "kind": {
    "data": {
      "args": [],
      "contract_identifier": "STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0",
      "method": "cast-vote"
    }
    ...
  }
  ...
}
```

The final element to analyze in the `metadata` object is the `receipt` object, particularly its `events` array and the objects within it.

For your `contract_call`, the relevant data is housed in the `data` object of these elements. Similar to the `kind` object, our `data` object includes a `contract_identifier` key, which in this case is linked to the `simple-vote-v0` contract.

Since you are using the `print` statement to return data from your contract's `cast-vote` function, the `events` array will contain `topic` and `value` keys.

The `topic` indicates that the print statement is being used to output data, while the `value` key will display the specific data set within that `print` function.

```json title="contract-call-payload.json"
// [!code word:receipt]
{
  "metadata":
  ...
  "receipt": {
    "contract_calls_stack": [],
    "events": [
      {
        "data": {
          "contract_identifier": "STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0",
          "topic": "print",
          "value": {
            "notification": "cast-vote",
            "payload": {
              "status": "Has voted set to true",
              "totalVotes": 1,
              "voter": "STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV"
            }
          }
        },
        "position": {
          "index": 0
        },
        "type": "SmartContractEvent"
      }
    ],
    "mutated_assets_radius": [],
    "mutated_contracts_radius": [
      "STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0"
    ]
  }
  ...
}
```

</Step>
</Steps>

---

Now that you've located the relevant data in the payload, you can start to extract the relevant information into your API.

The following is an example of how you might store your information in a database table:

| Block Height | Timestamp  | Transaction Identifier                                             | Success | Sender                                   | Result                        | Args | Contract Identifier                                     | Function  | Value                                                                                                                                                   |
| ------------ | ---------- | ------------------------------------------------------------------ | ------- | ---------------------------------------- | ----------------------------- | ---- | ------------------------------------------------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 21544        | 1722208524 | 0x98195af8f888d2f9ca3462c41c1691e7798ea6d9e5e3afe42955c0921f981f2c | True    | STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV | (ok "Vote cast successfully") | []   | STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV.simple-vote-v0 | cast-vote | \{"notification": "cast-vote", "payload": \{"status": "Has voted set to true", "totalVotes": 1, "voter": "STJ81C2WPQHFB6XTG518JKPABWM639R2X37VFKJV"\}\} |

## Next steps

<Cards>
  <Card
    href="stacks/chainhook/guides/chainhook-as-a-service"
    title="Chainhook as a Service"
    description="Learn how to run Chainhooks as a service."
  />
  <Card
    href="/stacks/chainhook/references/scopes"
    title="Scopes"
    description="Learn how to use scopes to scan for specific blockchain events."
  />
</Cards>
